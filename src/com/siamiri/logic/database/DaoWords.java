package com.siamiri.logic.database;

import com.siamiri.Model.word.Word;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object to perform the
 * CRUD operations on the DbTable.
 */
public class DaoWords extends ASqlKeyWords {
	
	//region 0. Konstanten
	/**
	 * Primary key of all tables of this project
	 */
	protected static final String COL_NAME_ID                    = "User_id";
	protected static final String COL_NAME_ID_INC_COL_BACK_TICKS =
			CHAR_COL_BACK_TICK + COL_NAME_ID + CHAR_COL_BACK_TICK;
	
	protected static final String COL_NAME_GERMAN_WORD               = "German Word";
	protected static final String COL_NAME_GERMAN_INC_COL_BACK_TICKS =
			CHAR_COL_BACK_TICK + COL_NAME_GERMAN_WORD + CHAR_COL_BACK_TICK;
	
	protected static final String COL_NAME_ENGLISH_WORD               = "English word";
	protected static final String COL_NAME_English_INC_COL_BACK_TICKS =
			CHAR_COL_BACK_TICK + COL_NAME_ENGLISH_WORD + CHAR_COL_BACK_TICK;
	
	protected static final String COL_NAME_LEITNER_BOX                    = "Leitner Box";
	protected static final String COL_NAME_LEITNER_BOX_INC_COL_BACK_TICKS =
			CHAR_COL_BACK_TICK + COL_NAME_LEITNER_BOX + CHAR_COL_BACK_TICK;

	protected static final String COL_NAME_DATE                   = "Date added";
	protected static final String COL_NAME_DATE_INC_COL_BACK_TICKS =
			CHAR_COL_BACK_TICK + COL_NAME_DATE + CHAR_COL_BACK_TICK;
	
	
	private static final String TABLE_NAME = "Word List";
	//endregion
	
	
	//region 1.Insert data and/or list of data
	
	/**
	 * Inserts just one data into the database table
	 *
	 * @param dbRwConnection           : {@link Connection} : Db-Connection with write and read access
	 * @param wordToInsertIntoDbTable : {@link Word : Model to be inserted
	 */
	public void insertDataRecordIntoDbTbl(Connection dbRwConnection, Word wordToInsertIntoDbTable) {
		
		//Decl and Init
		Statement dbStatementToExecute = null;
		
		try {

			// Statement to execute the SQL statement as a string.
			dbStatementToExecute = dbRwConnection.createStatement();
			

			String strSqlStmtInsert = INSERT_TBL + TABLE_NAME + CHAR_OPEN_BRACKET
					+ COL_NAME_GERMAN_INC_COL_BACK_TICKS + CHAR_COMMA
					+ COL_NAME_English_INC_COL_BACK_TICKS + CHAR_COMMA
					+ COL_NAME_LEITNER_BOX_INC_COL_BACK_TICKS + CHAR_COMMA
					+ COL_NAME_DATE_INC_COL_BACK_TICKS
					+ CHAR_CLOSE_BRACKET
					+ VALUES_OPERATOR + CHAR_OPEN_BRACKET
					+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getGermanWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getEnglishWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getBoxNumber() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getDate() + CHAR_VALUE_BACK_TICK
					+ CHAR_CLOSE_BRACKET_SEMICOLON;

			System.out.println(">>>>>>>> " + strSqlStmtInsert);
			
			// Pass SQL string to statement object to execute
			dbStatementToExecute.execute(strSqlStmtInsert);
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				// Close the statement
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				//6. Close the connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
		
		
	}
	
	/**
	 * Inserts a list of data into the Data bank table
	 *
	 * @param dbRwConnection            : {@link Connection} : Db-Connection Read and Write access
	 * @param wordsToInsertIntoDbTable	: {@link Word} : The model which should be inserted
	 */
	public void insertDataRecordsIntoDbTbl(Connection dbRwConnection, List<Word> wordsToInsertIntoDbTable) {

		//Decl and Init
		Statement dbStatementToExecute = null;
		
		try {
			/*
			* The Db Connection is already generated by DbManger
			* Statement object to execute the SQL statement
			* generated as a string.
			 */

			dbStatementToExecute = dbRwConnection.createStatement();
			

			for (Word wordToInsertIntoDbTable : wordsToInsertIntoDbTable) {
				
				String strSqlStmtInsert = INSERT_TBL + TABLE_NAME + CHAR_OPEN_BRACKET
						+ COL_NAME_GERMAN_INC_COL_BACK_TICKS + CHAR_COMMA
						+ COL_NAME_English_INC_COL_BACK_TICKS + CHAR_COMMA
						+ COL_NAME_LEITNER_BOX_INC_COL_BACK_TICKS + CHAR_COMMA
						+ COL_NAME_DATE_INC_COL_BACK_TICKS
						+ CHAR_CLOSE_BRACKET
						+ VALUES_OPERATOR + CHAR_OPEN_BRACKET
						+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getGermanWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
						+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getEnglishWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
						+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getBoxNumber() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
						+ CHAR_VALUE_BACK_TICK + wordToInsertIntoDbTable.getDate() + CHAR_VALUE_BACK_TICK
						+ CHAR_CLOSE_BRACKET_SEMICOLON;

				// Pass statement object to execute
				dbStatementToExecute.execute(strSqlStmtInsert);
				
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				// Close Statements
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				// close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
	}
	//endregion
	
	//region 2. Update data and/or list of data
	
	/**
	 * modifies a single word in the database table
	 *
	 * @param dbRwConnection         : {@link Connection} : Db-Connection with read and write access
	 * @param wordToUpdateInDbTable : {@link Word} : Model which should be change
	 *
	 */
	public void updateDataRecordIntoDbTbl(Connection dbRwConnection, Word wordToUpdateInDbTable) {
		
		Statement dbStatementToExecute = null;
		try {

			/*
			* Db Connection by DbManager
			* Generate statement object
			 */

			dbStatementToExecute = dbRwConnection.createStatement();

			String strSqlStmtUpdate = UPDATE_TBL + TABLE_NAME
					+ SET_OPERATOR
					+ COL_NAME_GERMAN_INC_COL_BACK_TICKS
					+ EQUALS_OPERATOR
					+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getGermanWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ COL_NAME_English_INC_COL_BACK_TICKS
					+ EQUALS_OPERATOR
					+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getEnglishWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ COL_NAME_LEITNER_BOX_INC_COL_BACK_TICKS
					+ EQUALS_OPERATOR
					+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getBoxNumber() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
					+ COL_NAME_DATE_INC_COL_BACK_TICKS
					+ EQUALS_OPERATOR
					+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getDate() + CHAR_VALUE_BACK_TICK
					+ WHERE_CONDITION + COL_NAME_ID_INC_COL_BACK_TICKS + EQUALS_OPERATOR + wordToUpdateInDbTable
					.getWordUserIdIndex();
			
			System.out.println(">>>>>>>> " + strSqlStmtUpdate);
			
			// pass string statement as object to execute SQL
			dbStatementToExecute.executeUpdate(strSqlStmtUpdate);
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				//5. close statement
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				//6. close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
	}
	
	/**
	 * Change a list od data
	 *
	 * @param dbRwConnection          	: {@link Connection} : read and write Db-Connection
	 * @param wordsToUpdateInDbTable	: {@link Word} : the list should be change
	 */
	public void updateDataRecordsIntoDbTbl(Connection dbRwConnection, List<Word> wordsToUpdateInDbTable) {
		Statement dbStatementToExecute = null;
		try {

			/*
			 * Db Connection by DbManager
			 * Generate statement object
			 */

			dbStatementToExecute = dbRwConnection.createStatement();
			
			for (Word wordToUpdateInDbTable : wordsToUpdateInDbTable) {

				String strSqlStmtUpdate = UPDATE_TBL + TABLE_NAME
						+ SET_OPERATOR
						+ COL_NAME_GERMAN_INC_COL_BACK_TICKS
						+ EQUALS_OPERATOR
						+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getGermanWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
						+ COL_NAME_English_INC_COL_BACK_TICKS
						+ EQUALS_OPERATOR
						+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getEnglishWord() + CHAR_VALUE_BACK_TICK + CHAR_COMMA
						+ COL_NAME_LEITNER_BOX_INC_COL_BACK_TICKS
						+ EQUALS_OPERATOR
						+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getBoxNumber() + CHAR_VALUE_BACK_TICK
						+ COL_NAME_DATE_INC_COL_BACK_TICKS
						+ EQUALS_OPERATOR
						+ CHAR_VALUE_BACK_TICK + wordToUpdateInDbTable.getDate() + CHAR_VALUE_BACK_TICK
						+ WHERE_CONDITION + COL_NAME_ID_INC_COL_BACK_TICKS + EQUALS_OPERATOR + wordToUpdateInDbTable
						.getWordUserIdIndex();
				
                System.out.println(">>>>>>>> " + strSqlStmtUpdate);
				
				dbStatementToExecute.executeUpdate(strSqlStmtUpdate);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				//5. close file
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				//6. close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
	}
	//endregion
	
	
	//region 3. read from data bank
	
	/**
	 * Returns all records of a database table as {@link List}
	 *
	 * @param dbRwConnection			: {@link Connection} : Db-Connection witch read and write access
	 *
	 * @return allDataRecordsFromDbTbl	: {@link List} Objects extended from {@link Word}
	 */
	public List<Word> getAllDataRecordsFromDbTbl(Connection dbRwConnection) {

		//Decl. and Init
		List<Word> allWordFromDbTable = new ArrayList<>();
		
		
		Statement dbStatementToExecute = null;
		
		try {
			/*
			* Connection is open
			* and unified by DbManger
			*
			* Generating statement
			*/

			dbStatementToExecute = dbRwConnection.createStatement();
			
			// Generate and submitting query and remember result set
			String strSqlStmtGetAll = SELECT_ALL_DATA_FROM + TABLE_NAME;

			ResultSet resultSetFromExecutedQuery = dbStatementToExecute.executeQuery(strSqlStmtGetAll);
			
			while (resultSetFromExecutedQuery.next()) {
				
				Word wordFromDbTable = this.getModelFromResultSet(resultSetFromExecutedQuery);
				
				// Add model object to matching list
				allWordFromDbTable.add(wordFromDbTable);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				// close Statement
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				// close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
		
		return allWordFromDbTable;
	}
	
	/**
	 * Returns a specific record of a database table
	 *
	 * @param dbRwConnection : {@link Connection} : Db-Connection mit Schreib und Lesezugriff
	 * @param iId			 :	int : Id of the object to be read from the DbTable
	 *
	 * @return specificDataRecordFoundById : {@link Word}  nad/ot
	 * derived from it: searched object it is null, or if it does not exist
	 */
	public Word getSpecificDataRecordFromDbTblById(Connection dbRwConnection, int iId) {
		Word specificWord = null;
		
		//Decl. and Init
		
		Statement dbStatementToExecute = null;
		
		try {
			/*
			 * Connection is open
			 * and unified by DbManger
			 *
			 * Generating statement
			 */
			dbStatementToExecute = dbRwConnection.createStatement();
			
			/*
			 * Generate and submit query
			 * remember result set SELECT *
			 * FROM words WHERE _id = 1 or
			 * can be different Id
			 */
			String strSqlStmtGetById =
					SELECT_ALL_DATA_FROM + TABLE_NAME + WHERE_CONDITION + COL_NAME_ID + EQUALS_OPERATOR + iId;
			
			ResultSet resultSetFromExecutedQuery = dbStatementToExecute.executeQuery(strSqlStmtGetById);
			
			// ResultSet == Run through the result set until there are no more data sets left
			if (resultSetFromExecutedQuery.first()) {
				
				// From the result set a word procured
				
				specificWord = this.getModelFromResultSet(resultSetFromExecutedQuery);
				
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				// close statements
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				// close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
		
		return specificWord;
	}
	//endregion
	
	
	//region 4. Delete from data bank
	
	/**
	 * delete specific word from data bank
	 *
	 * @param dbRwConnection : {@link Connection} : Db-Connection read and write is accessible
	 * @param iId            : int : Id of the object that want to be deleted from the list
	 */
	public void deleteDataRecordInDbTblById(Connection dbRwConnection, int iId) {
		Statement dbStatementToExecute = null;
		
		try {

			// open connection and statement

			dbStatementToExecute = dbRwConnection.createStatement();

			//generate statement

			String strSqlDeleteWordById = ASqlKeyWords.DELETE_FROM_TBL + TABLE_NAME + WHERE_CONDITION
					+ COL_NAME_ID_INC_COL_BACK_TICKS
					+ ASqlKeyWords.EQUALS_OPERATOR + iId;
			
			dbStatementToExecute.executeUpdate(strSqlDeleteWordById);
			
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			
			if (dbStatementToExecute != null) {
				// close statements
				try {
					dbStatementToExecute.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
			
			if (dbRwConnection != null) {
				// close connection
				try {
					dbRwConnection.close();
				} catch (SQLException sqlEx) {
					sqlEx.printStackTrace();
				}
			}
		}
	}
	//endregion
	
	//region 5. FORM the model FROM the result
	
	/**
	 * This section we take the result
	 * and form a concentrate model from it
	 *
	 * @param currentResultSet	: {@link ResultSet} : Result set of the current query
	 *
	 * @return wordFromDb		: {@link Word} : Model derived from the base class
	 *
	 * @throws Exception		:
	 *
	 */
	protected Word getModelFromResultSet(ResultSet currentResultSet) throws Exception {

		// Read the index
		final int iColumnUserIndex		= currentResultSet.findColumn(COL_NAME_ID);
		final int iColumnGermanWord		= currentResultSet.findColumn(COL_NAME_GERMAN_WORD);
		final int iColumnEnglishWord	= currentResultSet.findColumn(COL_NAME_ENGLISH_WORD);
		final int iColumnLeitnerBoxNum	= currentResultSet.findColumn(COL_NAME_LEITNER_BOX);
		final int iColumnDate			= currentResultSet.findColumn(COL_NAME_DATE);


		// By selecting the data type and specifying the column indices to the data it will be deleted

		final int iId			= currentResultSet.getInt(iColumnUserIndex);
		final String strGerWord	= currentResultSet.getString(iColumnGermanWord);
		final String strEngWord	= currentResultSet.getString(iColumnEnglishWord);
		final int    iLeitner	= currentResultSet.getInt(iColumnLeitnerBoxNum);
		final String strDate	= currentResultSet.getString(iColumnDate);


		// Generate new model object
		Word wordFromDb = new Word();
		
		wordFromDb.setWordUserIdIndex(String.valueOf(iId));
		wordFromDb.setGermanWord(strGerWord);
		wordFromDb.setEnglishWord(strEngWord);
		wordFromDb.setBoxNumber(String.valueOf(iLeitner));
		wordFromDb.setDate(strDate);
		
		
		return wordFromDb;
	}
	//endregion
	
	
}
